目前我们的管理系统都是基于iview-admin创建的，它提供了一个基础模板，涵盖了一些常用业务组件和通用的登陆退出等逻辑。

### 创建项目

1. 直接使用iview-admin的基础模板

   问题：

   - 国际化,错误收集等功能不需要
   - 登陆，权限等逻辑不符合需求
   - 有许多额外的自带界面需要删除
   - 需要加入axios错误处理，登陆验证码插件等业务通用功能

2. 使用脚手架创建

   `generate admin --project-name demo`

   `generate init --repo vuejs/vue --path ./demo`

   好处：

   - 集成了业务通用功能，不用去东拼西凑找其他项目代码
   - 去除了iview-admin的无用功能

   问题：

   - 当模板出问题时，需要更新脚手架。最终还是自己来修复改问题。

### 添加功能模块

以一个todos的增删改查功能为例

1. 一般方式

   ​	在view中创建todos目录，添加列表，表单，弹窗等增删改查逻辑和页面

   ​	问题：

   - 增删改查项目的界面布局和逻辑基本类似，每次都重复编写逻辑很浪费时间

2. 使用脚手架创建

   ​	`generate crud --resouce todo`

   ​	`generate crud-vuex --resouce todo --path ./src/view --store-path src/store/module`

   添加路由

   ```js
   {
           path: '/todos',
           name: 'todos',
           redirect: '/todos/table',
           meta: {
               title: 'todos',
               icon: 'md-albums'
           },
           component: Main,
           children: [
               {
                   path: '/todos/table',
                   name: 'todos-table',
                   meta: {
                       title: 'todos',
                       icon: 'md-albums'
                   },
                   component: () => import('@/view/todos/index.vue')
               }
           ]
       }
   ```



   好处：

   - 直接得到增删改查界面布局和通用逻辑，只需填写接口调用逻辑，比较方便

   问题：

   - 界面逻辑复杂的时候，最终还是回归传统方式来创建。不管有多少种模板，也不可能覆盖到所有的业务场景。
   - 接口调用，路由还是要手动加入

3. 为什么不使用crud组件
iview等组件库已经抽离了基本组件，基于此再封装一层会增加使用的复杂度，如不一致的props，事件等，开发时需要额外参考一份文档。
并且这种组件只能涵盖增删改查逻辑，如果业务需求复杂一些，变化一些，还是需要加入许多自定义的东西，还不如直接的代码看起来直观，更容易维护。

### 编写方式

在这几个方面提高可维护性

- 数据管理
- 命名规范
- 代码组织方式

1. 数据管理
对于不同view之间共享的数据，使用vuex管理
对于同一层view里的多个组件共享的数据，可以使用类flux的store模式。
```
var store = {
  state: {
    message: 'Hello!'
  },
  setMessageAction (newValue) {
    if (this.debug) console.log('setMessageAction triggered with', newValue)
    this.state.message = newValue
  },
  clearMessageAction () {
    if (this.debug) console.log('clearMessageAction triggered')
    this.state.message = ''
  }
}

var vmA = new Vue({
  data: {
    privateState: {},
    sharedState: store.state
  }
})
```
该方式比vuex的使用更简单，但也有一些问题。
- 组件unmount之后，store里的数据不会清除，需要手动根据需要清除数据

2. 命名规范
- 事件名on开头，事件处理函数handle开头
- 组件使用时kebab-case ，声明时PascalCase
- 组件生命周期等声明顺序
    - components
    - props
    - data
    - created
    - mounted
    - activited
    - update
    - beforeRouteUpdate
    - metods
    - filter
    - computed
    - watch

3. 代码组织方式
对于一个增删改查功能，可以采取这样的目录结构
```
- view
    - todos
        - components
            - edit-modal.vue
        - store
            - index.js
        - index.vue
```
对于一个多菜单的模块，可以这样
```
- customers
    - module1
        - components
        - store
        - index.vue
    - module2
        - components
        - store
        - index.vue
```
子模块间如果需要可以互相引用，可能会使得引用混乱。

### 抽离通用业务逻辑
1. 登录状态
- 使用cookie保存登录状态的方式
- 使用getUserInfo/getStatus获取登录状态的方式

2. 验证码

3. axios请求拦截，错误处理等

4. 更新日志
